0> How do we compute abstract forward transformers on the SSA generated from summarizer
1> ssa_fixed_point.cpp inside domain is used to perform the forward and backward propagation to derive the 
   strongest post-condition and weakest pre-condition. This is equivalent to the BCP step of the SAT solver. The purpose is to compute 
   the obvious facts by propagation until a greatest fixed point is reached.

2> Why the divider circuit fails in summarizer. The assertion is simple. What options to run for this ? 

3> Do we follow the CDCL path for implementation or do we follow the AI path for implementation ? For ACDCL, the high level 
phases are BCP, decision, conflict, learn, backtrack. 

4> One abstract state per program location -- hoe does it handle things like relational ?
5> For loops, have both option: -- do unwinding and also do join.
6> Use octagons from Apron library? Does Apron library does not have backward transformer implementation.

7> SSA generation:
#include <limits.h>

void main() {
  int x,y,z;
  _Bool c;
      
  // abstract domain for booleans no implemented inside cdfpl
  // decisions on booleans has to be made
  if (c)
   x = -1;
  else
   x = 2; 
  // x = [-1,2]  
  z = x * x; // z = [0,4]
  assert((z!=2));
}

SUMMARIZER version 0.1.0 (based on CBMC 5.1)
Parsing filter.c
Converting
Type-checking filter
Generating GOTO Program
Adding CPROVER library
Generic Property Instrumentation
Function Pointer Removal
>>>> Function main
*** 0 file filter.c line 4 function main
(not marked)
(E) $guard#0 == TRUE

*** 4 file filter.c line 9 function main
(not marked)
(E) $cond#4 == (c#3 == FALSE)

*** 5 file filter.c line 10 function main
(not marked)
(E) x#5 == -1
(E) $guard#5 == (!$cond#4 && $guard#0)

*** 6 file filter.c line 10 function main
(not marked)
(E) $cond#6 == TRUE

*** 7 file filter.c line 12 function main
(not marked)
(E) x#7 == 2
(E) $guard#7 == ($cond#4 && $guard#0)

*** 8 file filter.c line 14 function main
(not marked)
(E) z#8 == x#phi8 * x#phi8
(E) x#phi8 == ($cond#6 && $guard#5 ? x#5 : x#7)
(E) $guard#8 == ($cond#6 && $guard#5 || $guard#7)

*** 9 file filter.c line 15 function main
(not marked)
(A) !$guard#8 || z#8 != 2

(enable) TRUE


>>>> Function _start
*** 15 
(not marked)
(E) $cond#15 == TRUE
(E) $guard#15 == TRUE
(F) __CPROVER_initialize()

*** 16 file filter.c line 3
(not marked)
(E) $cond#16 == TRUE
(E) $guard#16 == ($cond#15 && $guard#15)
(F) main()

*** 17 
(not marked)
(E) $guard#17 == ($cond#16 && $guard#16)

(enable) TRUE


>>>> Function __CPROVER_initialize
*** 18 
(not marked)
(E) $guard#18 == TRUE

*** 19 file <built-in-additions> line 31
(not marked)
(E) __CPROVER_dead_object#19 == NULL

*** 20 file <built-in-additions> line 32
(not marked)
(E) __CPROVER_malloc_object#20 == NULL

*** 21 file <built-in-additions> line 33
(not marked)
(E) __CPROVER_malloc_size#21 == 0ul

*** 22 file <built-in-additions> line 34
(not marked)
(E) __CPROVER_malloc_is_new_array#22 == FALSE

*** 23 file <built-in-additions> line 35
(not marked)
(E) __CPROVER_memory_leak#23 == NULL

*** 24 file <built-in-additions> line 21
(not marked)
(E) __CPROVER_thread_id#24 == 0ul

*** 25 file <built-in-additions> line 57
(not marked)
(E) __CPROVER_rounding_mode#25 == 0

*** 26 file <built-in-additions> line 22
(not marked)
(E) __CPROVER_threads_exited#26 == ARRAY_OF(FALSE)

*** 27 file <built-in-additions> line 23
(not marked)
(E) __CPROVER_next_thread_id#27 == 0ul

*** 28 file <built-in-additions> line 79
(not marked)
(E) __CPROVER_pipe_count#28 == 0u

*** 29 file <built-in-additions> line 30
(not marked)
(E) __CPROVER_deallocated#29 == NULL

(enable) TRUE

Peter+Bjorn Discussion, 3rd July 2015
--------------------------------------
1) ACDL starts with TOP in the beginning and has BOTTOM at all other cfg nodes. It computes the gfp. ACDL only computes the forward abstract transformers
2) Astree starts with BOTTOM in the beginning and at all other cfg nodes. It computes the lfp. It doesnot compute the backward transformers.


Note of the summarizer code
-----------------------------
1) class nodet is the SSA node for a location.

***** Discussion with Peter on 18th Nov, 2015 *****
*) --show-ssa with summarizer show different variable index (x#20) compared to running with --acdl 
and printing the variables inside acdl code. To resolve this, run acdl as follows:
./summarizer --inline --acdl main.c
*) Peter to merge summarizer code base with main trunk so that our branch is automatically updated.
*) Inside acdl_domain, implement is_top, is_bottom, is_complete
*) Inside acdl_solver, implement the whole acdl loop. Implement the decision, conflict analysis steps.
For decision see reference of leo's VSIDS heuristic. 

*) For pre-condition computation, the trick is to perform two way propagation. Project lhs on rhs and project rhs on lhs.
*) For bottom3 example, * and / does not work. Although + and - work correctly. i

// Daniel's suggestion to handle branches in SSA representation
Look at guards (guard variables in SSA) and make a decision on guards. 
Use the boolean part of guard to decide using MiniSAT and the non-boolean part of the guard to decide with 
abstract domains (intervals). What a decision variable would be in ACDL solver is not known yet !

*) For example where x=1; assert(x==2); is unknown. Because while calculating the projection and 
computing the new value, (x!=2) can not be expressed by interval domain !!

*) Computing the update worklist seems to be a problem. All dependencies are not pushed properly now.

*) We now use summarizer/2ls as executable to run acdl. To see the ssa representation, we now do --show-ssa --no-propagation
../../../src/summarizer/2ls --acdl main.c --show-ssa --no-propagation

*) We plan to build acdl with complete solver support now and no hardcore abstract domain implementation. The major difference 
between acdl and summarize is that acdl follow small step semantics of the program unlike large block encoding in summarizer.

Discussion with Peter
---------------------
1> We do multi-way propagation of abstract values for all nodes in SSA, that is, 
equalities, assertions and constraints. 

Queries:
--------
bottom3 is absolutely fine
bottom5 is showing unknown when it should show true: What happens when somethings holds ture  ?

Some observations:
------------------
1> Consider the following program:
int main() {
  int x, y;

  x = 8;
  y = x;
  assert(y!=15);
}
CBMC with MiniSAT(CDCL solver), cdfpl and acdl -- none of these algorithms made a single decision 
to infer that the program is safe. Only deductions are performed to ensure that the program is safe.

2> Consider the following program:
int main() {
  int x, y;

  x = 1;
  y = x + 3;
  x = y - 2;

  assert(x!=2);
}

***********************************************************
CBMC with MiniSAT(CDCL solver): --> This made one decision
***********************************************************
Solving with MiniSAT 2.2.0 with simplifier
72 variables, 11 clauses
SAT checker: negated claim is SATISFIABLE, i.e., does not hold
restarts              : 1
conflicts             : 0           
decisions             : 1           
propagations          : 4           
conflict literals     : 0           
Runtime decision procedure: 0s
Building error trace

***********************************************************
Leo's AI --> This made 66 decisions 
***********************************************************
ITERATION (decision) 66
================ 
{ c::$file::main::1::x in INT: [-2147483648, -2147483648], c::$file::main::1::y in INT: [-2147483648, -2147483648] }
new dlevel: 67
scores: -1 -1 
FAILED TO VERIFY PROGRAM
Minimal unsafe element: { c::$file::main::1::x in INT: [-2147483648, -2147483648], c::$file::main::1::y in INT: [-2147483648, -2147483648] }== Procedure terminated after 67 iterations 


**** Verification failed 
Found 1 possible assertion violations
********
5: ASSERT  x != 2
    GOTO 6
    Potential violation: x == 2 && y == 4

    Information over assertion variables: x == 2 

***********************************************************
ACDL with SSA
***********************************************************
Updated: x#19 <= 1 && x#21 <= 2 && x#21 <= 2147483647 && y#20 <= 4 && y#20 <= 2147483647 && -((signed __CPROVER_bitvector[33])x#19) <= -1 && -((signed __CPROVER_bitvector[33])x#21) <= 2147483648 && -((signed __CPROVER_bitvector[33])x#21) <= -2 && -((signed __CPROVER_bitvector[33])y#20) <= 2147483648 && -((signed __CPROVER_bitvector[33])y#20) <= -4 && $guard#0 == TRUE && $guard#0
Propagation finished with UNKNOWN
Note that the above constraints means the following: (x_19 = [1,1]) && (x_21 = [2,2]) && (x_21 = [-2^32, 2^32-1]) && (y_20 == [4,4]) && (y_20 == [-2^32, 2^32 - 1]) -- This is the abstract state now. No further deduction can be made now. 

My point: Now, if we decide on latest value of x which is x_21 = [-2^32, 0] (property-guided decision), then do propagation again, then what happens ? 
The way we can reach BOTTOM immediately when taking a meet of the decision with the present abstract state (shown above) leads to prving unsafety in one decision. 
Compared to AI, do we need 66 iterations to decide the unsafety of the program. Do we throw away existing abstract state when we make a new decision ? 
Do we propagate a new decision from the starting node again? 

Meeting with Peter on 9th Dec, 2015
------------------------------------
1> We implemented gamma-completeness check to see if the abstract state where 
every variable has a singleton value indeed is a concrete counterexample. 
The gamma completeness check is done when deduction is finished (worklist is empty), 
and every variable in the abstract state has a concrete assignment, we then check if the
these assignments are indeed a valid counterexample. To do so, we first take the abstract 
state and for each variable in the abstract state we negate the constraints associated with
it (eg, !(x == 2)) and decide with the solver whether the conjunction of the abstract state
with the negated clause involving the variable is UNSAT. If it is UNSAT, then it is a real 
counterexample. 

2> Peter To do: normalization of the abstract state while computing meet. 
For example, (x == [-2^32, 2^32-1]) && (x == [3,3]) --> normalize this to --> (x = [3,3])

3> Decision strategy: We decide on a variable using some heuristics and then split the bound 
of this variable to form a decision expression. Take the meet of the decision expression 
with the abstract state to derive a new abstract state. 

Queries:
*> For if-else program in regression, the following is shown by acdl.
prop_convt::convert_bool got non-boolean expression:
("constant" "type" ("signedbv" "width" ("32") "#c_type" ("signed_int")) "value" ("00000000000000000000000000000000") "#source_location" ("" "file" ("main.c") "line" ("4") "function" ("main")) "#cformat" ("0"))
 
*> Do I need to pass the expression template like (x-y) or (x) or (x>0) to the split function  

*) Since bottom2 has assertion (x==2) which is non-convex, so when is the decision made for this program. Is it 
in the beginning or after gamma-completeness.

*) How to check meet irreducible -- implement this. 

Meeting with Peter on 11th Dec, 2015
-------------------------------------
*> The guard variable in SSA is determined by the cond variable (for programs without loops). So, 
when cond==1, it implies guard==1.

*> SAT solver calls in our case is part of the abstract domain  

*> decision_graph contains the following information:
   edges: if the first decisions is (y<0), second decision is (x>0), then 
   there is an edge like this. x>0 ----> y<0 ----> nil_exprt() // Note that root is always nil_exprt()
   backtrack_points: this is map which contains decisions as index and abstract values at each decision points,
                     for example, backtrack_points[decision] = v; // where v is the abstract value 
   Our assumption is that the decisions are usually unique. That is, if (x<0) is decided once, then it will not be 
   decided in future. 

*> split function in the acdl_domain returns meet irreducibles. 
   For example, if (x!=2) it returns (x <= 1) V (x>=3)

Query:
1> Can we avoid pushing statements like y#18 == nondet_symbol(ssa::nondet18.1) ?
2> Check if the edge update implementation inside the decision is correct or not ?
3> If I have multiple if-else branch, which cond to decide on. Now the last cond is always taken.
4> If cond == (x==4), then !cond == (x!=4) which cannot be represented in the domain now
5> Do I need to empty the worklist before updating the worklist in conflict analysis phase ?
6> For the present error, either we take separate care for updating worklist for cond variables or 
the boolean case in acdl domain is wrong because the if-else were properly working without product domain.

Meeting on 14th December, 2015
---------------------------------
1> Updating worklist for conditionals seems to be a problem.
Conside the following case:
  Statement            Abstract value
  ---------           ----------------
guard0 = true            guard0=true
guard1 = guard0&&cond    guard0=true // no information available about cond which means that they are TOP
cond = (x<10)           
 x = 5
For the above situation, we need to look ahead upto x=5 and then compute the abstract value of guard1 
to mimic the deduction phase of the SAT solver. The deduction phase must guarantee that all informations
that is obvious must be computed, meaning gfp iteration in AI. 

Consider another situation:
  Statement            Abstract value
  ---------           ----------------
guard0 = true           guard0=true
guard1 = guar0&&cond    guard0=true // no information available about cond and guard which means that they are TOP
 cond = (x<10)
 x = h, h is symbolic                 
 y = g, g is symbolic

 
Meeting on 15th December, 2015
-------------------------------
1> Update worklist algorithm:
Intialize the worklist with the assertions at the beginning:
Let a1, a2, a3 be three assertions. Then, the worklist first 
stores (!(a1 && a2 && a3)). Compared to our last implementation, 
where we always store all the statement in the worklist that is 
dependent on the variables present in the current statement, in 
our new implementation, we need to store all transitive dependencies 
in the worklist as well. For this, we need to create a graph where
for each variables, we need to cache its corresponding transitive 
dependencies so that when the same variable arise next time, we 
do not have to track the whole dependencies for that variable again and 
  simply look at the graph. The contains check in the worklist still 
  remains the same for terminating condition. The graph must return 
  set of all statements which are dependant on the current selected 
  variable.
  
2> For Learning, look at Leo's first UIP algorithm and the data 
structure used there. Make a separate class for conflict_analysis.
The decision_grapht must have some mechanism to store the deduction 
as well as this is also needed in the first UIP algorithm.

3> Implement the decision heuristic, where decisions are taken on 
cond and assertion variables with meet irreducibles, like (x!=5) gives
us (-2^32,4) meet (6, 2^32-1)
 
   
Meeting on 16th December, 2015
-------------------------------
1> Insert into worklist in the following order:

Assert -------> top
Leaf   -------> Middle
Rest   -------> Bottom

2> Then while in deduction phase, when popping an element, process the element and then 
insert the same element in the end of the worklist.

Meeting on 8th January, 2016
-------------------------------
1> The decision_grapht must have some mechanism to store the deduction 
as well as this is also needed in the first UIP algorithm. How to store this ?
Show the code of updating the deduction list inside decision and the header file. 
Also, do we need to pass the decision graph as parameter to the propagate routine 
because that is where the new abastact value is computed ?

2> Then while in deduction phase, when popping an element, process the element and then 
insert the same element in the end of the worklist. If we do not do this step, will the
 analysis be unsound. 

3> Conflict analysis must return PASS if the learnt clause leads to proving the safety, 
else it always returns UNKNOWN.

4> branch3 did not terminate while branch2 terminated (similar program)

5> Run through all conditional variables, and pick up the first one where
decision is not done yet (split does not return false). This continues until 
split returns false for all conditional variables which means that the decision 
has been on all conditional variables and there are no conditional variables 
needed. If that is the case, then return to the meta heuristics to decide on 
numerical variables (say). — implement this in decision_heuristic_conditional
 
6> Gama completeness check is too restrictive — now works on singletons 
 
 
  
Meeting on 12th January, 2016
-------------------------------
For every propagation, we need to keep track of the variable which has been assigned a value 

A trail is a sequentialised version of the implication graph 
One decision — one propagation 
Implication graph is a more structured form of trail and contains additional information of causality (implications) — 
trail and implication graph — separate implementation
Nodes in an implication graph are either decisions or inferences 
Flags to determine whether a node is a decision or a inference 
The nodes of the implication graph are meet irreducibles 
The domain operator must return list of meet irreducibles that have been 
inferred 
Implement a clean implication graph — constraint in the nodes, each node 
are meet irreducibles (implication graph is independent of abstract domain).
Present decision level and list of implications — get a list of new nodes and 
for each new node, I have a list of parent nodes — only semantic information is parent node implies this new node, meet irreducible linked to the new node, 
  add a decision (meet irreducible of the decision) —
  Two methods 
  1> adding decision — just takes meet irreducible and increment decision level
  2> add an implication — list of parent nodes, and new node (meet irreducibles associated with it)
  3> add decision level at which to backtrack

Question 1>  We need to determine the update of meet irreducibles  — for pushing the elements which has been popped from the wordlist

Meeting on 15th January, 2016
-------------------------------
1> Create a separate class for implication graph and separate class for conflict analysis 


Meeting on 5th February, 2016
-------------------------------
1> The implementation of implication graph and domain computation for deduction
should be separate
2> The nodes in the implication graph are meet irreducibles.
Let the current partial assignment be: {x>=0, x<=10, y>=5, y<=8}, all are meet
irreducibles
Let the statement be: x'=x+y
Then, abstract value returned by the domain is: (x' >= 5, x' <= 18), which is a
meet irreducible
Now, the deduction information is computed as follows:
{x >= 0, y >= 5} --> (x' >= 5), here {x>=0, y>=5} is the antecedent or the child
nodes in the implication graph which points to (x' >= 5) 
{x <= 10, y <= 8} --> (x' <= 18), here {x<=10, y<=8} is the antecedent or the child
nodes in the implication graph which points to (x' <= 18)

In particular, we look for which meet irreducibles are responsible for
deducing which other meet irreducibles, these meet irreducibles are added 
are added as nodes in the implication graph. We need to infer this information 
from the SAT solver.

3> Interface to the implication graph: 
   a> add deduction 
   b> add decision 
   c> backtrack to level (index)
   
4> Conflict clauses are always added as a "conditional" to the SSA and not as 
"assignments". Like in SAT solver where conflict clauses are added in the 
clause database, we need to maintain a separate list of conflict clauses 
that are discovered. Later, we need to add these conflict clauses as 
set of SSA's (ultimately added to the worklist) so that they 
partiticipate in the subsequent deduction phase. Does conflict 
clause always have to be unit clause after backtracking because 
literals in conflict clause are flipped to reverse the decision ? 
 
Meeting with Marcelo on 5th February, 2016
-------------------------------------------
1> ACDL is a forward cheap analysis which computes strongest post-condition 
with backward expensive analysis which computes weakest pre-condition. 

2> How do ACDL different from SMT solvers. In SMT, decisions and learning
happens in a theory solver. In ACDL, decision and learning happens in a 
domain. Domains in ACDL correspond to theory in SMT. But ACDL performs 
fix-point theory learning in the conflict analysis phase. 

TODO:
IMPORTANT POINT:
----------------
1> When propagation finish with BOTTOM, empty the worklist and empty the live
variables. Becuase the present decision lead to BOTTOM, so whatever is in the 
worklist, everything is invalid and need to be thrown out before we enter into 
the conflict analysis phase. Remember that we guarantee before entering into
decision phase, that is the last propagation step before decision, the worklist 
is empty and live variables are empty. Further, when the propagation finish with 
BOTTOM, the conflict analysis phase must only start with the learnt clause in
the worklist and live variables being empty.

2> nondet  symbols during worklist update is pushed now. Don’t push nondet
elements when updating worklist.

3> cond = (x <= 0), when a decision is made on cond, then all elements dependent
on cond is pushed. 
But in addition to that, all statements dependent on x should also be pushed. We
do not do this now, so the effect of (x <= 0) is not propagated further. 
Algo for point 2: 
a> add (x<=0) as decision in to the implication graph, instead of cond 
b> update the worklist based on cond (lhs), as well as (x<=0) (rhs). Normally
we update worklist based on lhs only, but for cond statements we update 
worklist based on lhs and rhs as well 

4> For the negation of  (cond == (x <= 0)), do the following:
a> Add !(x<=0) in to the implication graph.  
b> update the worklist based on cond (lhs), as well as (x<=0) (rhs).
   but for cond statements we update worklist based on lhs and rhs as well 

Discussion:
1> For the negation of  (cond == (x <= 0)), do the following:
   a> Add !(cond) in to the implication graph.  

2> Make the decision heuristic structured:
    init() -- function in acdl_solver that implements the following :
       dec_heuristic_cond.init() -- initialize the container with boolean variables
       dec_heuristic_int.init() -- initialize the container with bit-vector variables
    class dec_heuristic_all : dec_heuristic_baset
    {
      decide() {
        dec_heuristic_cond;  
        dec_heuristic_bv;  
      }
    }
3> For recursive deductions in Implication graph, when added 10->3, dont add
3->10    
4> Add learned clause to the conflict_literal container.

April 2014:
Query: 

1> Do we change (not flip but select a different variable) the present decision
when the present decision is not complete ? We always flip the present decision
when it leads to conflict.

Peter Meeting:
--------------
1> Do we make changes to the meet irreducible like !(-x<=10) in the abstract value 
temporarily for computing l and u for the splitting function or we change all
these negated meet irreduciblet permanantly in the abstract value itself ?

2> Check the implementation of computing l or u in domain.split. Specially 
creating meet_irreduciblet like (x >= -10), where I created (-10) with
mp_integer. 

3> !(ID_le) --> ID_gt, !(ID_ge) --> ID_lt

4> How to use the return value from the dominator (uip). How can I access the node_index for the UIP ? 
Look for the dominator that has the smallest target_sett and also contains the
conflict_node (false_exprt).

Meeting on 12th May 2016
------------------------
1> Do we call normalize_val only after we add a new decision to the 
implication graph so that decision splitting can be done or call normalize_val
before is_complete() function is called because we need to take into account the 
implication graph.

2> the conflict clause is constructed depending on the kind of proof
(propositional, ai, bmc).  

Meeting queries 
-----------------
1> Does the structure of the implication graph in non-propositional case satisfy the resolution prrof structure ? Otherwise, it is not directly clear if
first-uip is the right conflict point.
2> Checking whether a learned clause is a UNIT clause ?
3> checking whether dominator finds correct, not implemented with marking.
4> Generalisation 
5> branch7 example debug 
6> CAV attend, diffblue (delivery date), dkr to github 
7> Do we pass the additional constrait from loop head in every deduction step
separately. Now, we only do it for worklist initialize

TODO (23rd June, 2016)
----------------------
1> Use enable heuristics inside tpolyhedra to not make subsequent iterative decisions
2> Eugene contact -- conflict clause being UNIT

Peter Meeting 
-------------
1> branch7 is_completeness check failing despite computing the values correctly
in the deduction phase. Could be due to normalize_val after deductions or
decision. 

Query for July, 2016
---------------------
1> conflict analysis separate class -- for backtracking and without backtracking 
2> why is the SSA for the program below as follows:
int main()
{
  int x=0, y, z;
  _Bool c;
  if(c)
    x=x+1;
  else
    x=x-1;
  assert((x != 0));
}

SSA without constant propagation:
---------------------------------

*** 2 file main.c line 3 function main
(E) x#2 == 0                          

*** 4 file main.c line 3 function main
(E) y#4 == nondet_symbol(ssa::nondet4.1)

*** 6 file main.c line 3 function main
(E) z#6 == nondet_symbol(ssa::nondet6.1)

*** 8 file main.c line 4 function main
(E) c#8 == nondet_symbol(ssa::nondet8.1)

*** 9 file main.c line 5 function main
(E) $cond#9 == (c#8 == FALSE)         

*** 10 file main.c line 6 function main
(E) x#10 == 1 + x#2                    
(E) $guard#10 == (!$cond#9 && $guard#0)

*** 11 file main.c line 6 function main
(E) $cond#11 == TRUE                   

*** 12 file main.c line 8 function main
(E) x#12 == -1 + x#2                   
(E) $guard#12 == ($cond#9 && $guard#0) 

*** 13 file main.c line 9 function main
(E) x#phi13 == ($guard#12 ? x#12 : x#10)
(E) $guard#13 == ($cond#11 && $guard#10 || $guard#12)
(A) !(x#phi13 == 0) || !$guard#13                    

3> how to extract a symbol_exprt from meet_irreducible (x>3);
exprt lhs = to_binary_relation_expr(exp).lhs(); -- gives the exprt,
but how to convert this to symbol_exprt
For meet irreducible (-x<=-2), does the symbol_expr look like x or -x ? 

3> how to extract the number for a symbol_exprt after using hash function

4> Does the last deduction always guarantee us the most recent value of all the
variables in the program. Then we just trace back the propagation trail until
the last decision point and get all the updated values of the variables in the
program. 

5> we now have a consistency check for the abstract value from implication
graph -- the trail must not have  

Query for June 11, 2016
-----------------------
1> Unit rule implementation: 
  
  a> Do we add the unit_literal(meet_irreducible) directly to the graph. 
  If all meet irreducible but one is contradicting in a clause, we call the
  clause to be unit. 
    1> The one you mentioned.
    Abstract value:  ($x \in [5,13]$, $y \in [-2,9]$)
    Clause: (x<4 \vee y>10 \vee z<15)

    Deduction after application of unit rule: z<15
    New abstract value: ($x \in [5,13]$,  $y \in [-2,9]$,  $z \in [-INF,14]$)

    2> Abstract value: ($x \in [5,13]$,  $y \in [-2,9]$, $z \in [10,18]$).
    Clause: $C=(x<4 \vee y>10 \vee z<15)$
    Here, the literals x<4 and y>10 are contradicting. And z<15 is unit literal.

    Deduction after application of unit rule: z<15
    Abstract value: ($x \in [5,13]$, $y \in [-2,9]$, $z \in [10,14]$).

    3> Abstract value (x > 5, y < 20, z > 5).
    Clause: $C=(x<3 \vee y>50 \vee z<10)$
    Here, the literals x<3 and y>50 are contradicting. And z<10 is UNKNOWN, so
    the clause is UNIT. Unit literal is z<10.

    Deduction after application of unit rule: meet(z>5, z<10) --> z:[5,10]
    Abstract value: ($x \in [5,13]$,  $y \in [-2,9]$, $z \in [5,10]$).


  b> [IMP] Check if the implementation is correct ? -- iterate over each expr in the 
  clause and each value in abstract value -- any effecient way ?

  c> Do we need to consider ordering while comparing meet irreduccibles.
  How to find a meet irreducible is SATISFYING ?
  that is how to compare (x<5 less than or equal to x<10) using SAT query.
  How to compare an octagon is less than or equal to another octagon ? 


  d> unit_rule is in acdl_domain. But each time we apply unit rule, it performs
  some deductions for us. How to add those deductions directly to the conflict
  graph since domain does not have access to conflict graph. 
2> how to access the enum type of other class. 

3> [IMP] Do we need to handle the conflict clauses explicitly for doing AI style
propagation ? Shouldn't the propagation at clause level make
deductions which already restricts the propagation at AI level ?

4> loop handling in different cases:
    a> widening
    b> unwinding 
    c> invariant  

 
Query for June 14, 2016
------------------------
1> Generalisation in ACDL
2> Formalize Algo for loops
3> bottom9 example when run with no backjumping lead to storing inconsistent
decision epxr of the form x>0,x<0 in the trail which lead to assertion failue.
4> bottom9 example with clause learning leads to inconsistent decision
(different phase)
5> branch8: deduction cond#23 == (c#22==FALSE) is not done even though cond#23 
is decided. Atually, c#22 is not bool nor ID_signed. It has 8 bits being a
bool-- why is this ? 
6> build_meet_irreducible_templates does not return template when passed
non-boolean variables. It shows:
Program received signal SIGFPE, Arithmetic exception.
7> When the build_meet_irreducible_template returns x+y, x-y, -x+y, then 
do we search for values of x and y in the abstract value such that 
  x<=5, y<=3, then construct the following meet irreducibles like follows:
  x+y<=8
  x-y<=2
  y-x<=-2-x-y<=-8
  When we use --octagons, how do we guarantee that the deductions made are also
  octagons.
8> When do we change the phase of a variable, that is pass split(lower). 


Query for June 27, 2016
------------------------
0> Decision infeasibility -- determined inside decision heuristics 
1> when to change the phase of decision dynamically ?
2> What decision we need for solving bottom9 with octagons ? Don't we need
equality domain to solve this ? 
int main() {
 unsigned x, y;
 __CPROVER_assume(x==y);
 x++; y++;
 x++; y++;
 assert(x==y);
}
3> git query for bottom9 -- Deduction generated for octagon not proper ?
4> DATE bounded acdl experiments -- decisions and learning heuristics --
deadline 18th Sept. 


Query for August 8, 2016
------------------------
1> purpose of enabling_expr -- check implementations of get_enabling_exprs() ?
2> ignore lb variables for completeness check -- git issue (does all "ls" variable need to be false)
3> loop1-safe and loop1-unsafe example.  
4> how to split on array variable ?
5> Can we make decisions on variables which fails in completeness check ?

Query for August 8, 2016
------------------------
1> We need different propagation heuristics :
   a> forward analysis with strongest post-condition
   b> backward analysis with weakest pre-condition
   c> Chaotic iteration
Does the forward and chaotic iteration generate the same deductions always ?
Does chaotic iteration generate stronger deductions than forward or backward ?
For forward analysis, how do we get statement ordering of SSA ?
3> Is there any code in 2ls for forward analysis using strongest post on SSA ?
2> For running acdl with loops, do we need to specify "no unwinding assertions"
with --unwind option ? 
4> Make ACDL work by unwinding loops -- DATE benchmarks.
5> How to add acdl options for help function (2ls --acdl --help) ?
6> Can we make decisions on "lb" variables when handling loops with unwinding ?
8> Should the decision heuristics make decision on loop index variable (i#20%0,
i#20%1) ?
7> Can we decide on "%" variables that gets generated for every loop iterations. 
7> The following loop assertion shows "VERIFICATION INCONCLUSIVE" with --acdl --unwind 2. 
int main() {
  int x=0,i;
  for(i=0;i<=1;i++)  
    x = x+i;
  assert(x>20);
}
Whereas, with the assert(x<2) or assert(x==20), it fails. 

Query for August 30, 2016
--------------------------
0> for bug0, the loop problem is fixed. But since the assertion is inside the
loop, acdl does not stop when the assertion fails after unwind 3 in the first 
deduction step. (DONE) 
3> bottom9 must terminate after first propagation stage -- not happening now. (TBD)
4> how to normalize on octagon meet irreducibles. 
1> Can we make decisions on function return_value ?
2> relation3 -- does not terminate with intervals as well as octagons ? 2ls
terminate very quickly.
When run with cbmc, the SAT statistics shows the below:
SAT checker: instance is UNSATISFIABLE
restarts              : 4
conflicts             : 410
decisions             : 2597        (0.00 % random)
propagations          : 17095
conflict literals     : 2552    
4> bug3 is incorrect.
search for "FALSE <==", how can the following deduce to FALSE.
[ACDL-DOMAIN] deductions: FALSE <== !(y#phi64%2 >= 10) && !(-((signed
__CPROVER_bitvector[33])y#phi64%2) >= -4) && !(-((signed
__CPROVER_bitvector[33])y#phi46%1) >= -4) && !(-((signed
__CPROVER_bitvector[33])y#phi46%1) >= -8) && !(y#phi64%2 >= 9)
5> Bottom 9 example:When pop:y18=y16+1, then no deduction is present combining
x,y but deductions are only made on y. Though assumption statement is
represented correctly.
[ACDL-DOMAIN] deductions: !((unsigned __CPROVER_bitvector[33])y#18 +
(unsigned __CPROVER_bitvector[33])y#21 >= 8589934590) <==
!((signed __CPROVER_bitvector[33])y#21 + -((signed __CPROVER_bitvector[33])y#18)
>= 2) <==
!((signed __CPROVER_bitvector[34])-((signed __CPROVER_bitvector[33])y#18) +
-((signed __CPROVER_bitvector[34])y#21) >= 0) <==


Query for 5th Sept., 2016
--------------------------
-1> What is the point of considering varaibles of old abstract values for
"Template variables" in octagon domain.
0> show difference between temp and trace in bottom13 -- we need to be
conservative and do not delete map elements when no deduction is made, otherwise
we will miss some deductions -- branch1, branch4 gives erroneous result if this
conservative approach is not followed. 
1> When using octagon domain for programs which can be solved using only
intervals, there are large number of deductions made for octagon domain compared
to the interval domain -- example: branch2 shows deductions=80 using octagons
versus deductions=13 using interval domain --- can we make deductions using both
intervals and octagons using --octagons and --intervals.
1> deductions on boolean projections are extremely slow for octagon domain. 
2> relational3 -- pass successfully (but slow), relational4 -- did not teminate
3> Github issue: For forward iteration strategy, SSA representation has limitations. 
4> GIT issue: 
   unit-ness guarantee in octagon domain:
   checking unit rule for octagonal deductions:
   Abstract value: 
   (x+y > 0 && x-y < 2 && y-z <= 0 && z-y <= 0), where 
   x+y > 0 && x-y < 2 --> x=y+1
   y-z <=0 && z-y <=0 --> y==z
   Learnt clause: (L1 || L2 || L3) = (x > 10 || z > 3 || y+z < 5), obtained by negating 
   decisions {D1, D2, D3} as (L1 = !D1, L2 = !D2, L3 = !D3)
    *> x>10(L1) --> y>9
    *> y>9 --> !(y+z < 5), which violates L3 since z>3      
     
   Satiafiable literal: 
   Contradicting literal: y+z < 5
   Unknown literal: x>10, z>3

Query for 15th Sept., 2016
--------------------------
0> links for sv-comp benchmarks.
1> for octagons, how do we compute the interval decisions -- x-y <= 0, y-x<=0 --
how to compute the lower and upper bounds of intervals here. 
2> for octagonal unit_rule, do we separate the implementation from interval
unit_rule implementation ?
3> how to normalize octagon meet irreducibles -- not needed for unit rule but
needed for normalizing the trail
4> TACAS paper 

Qeury for next meeting
----------------------
0> pre-process SSA -- heavy-weight implementation, does not terminate for
relational2 even after 40 mins
1> pre-process -- change the following statement to a new form for which it
is hard to identify non-leaf variable 
(E) x#phi27 == ($guard#26 ? x#26 : x#24) changed to 
$guard#26 ? x#26 == x#phi27 : x#24 == x#phi27 
For the initial statement, it is easy to identify x#phi27 as left hand side
varaible needed for initializing worklist with leaf varaible, whereas it is 
not possible for the simplified statement to identify x#phi27 as lhs varaible.

4> Passing live variable for forware propagation:
You remember, we pass "vars" to domain for new deductions as below:
domain(statement, vars, old_v, new_v, deductions);
The question really is, for the Forward iteration strategy, do we follow a> or b> ?
a> vars = pass all live variables of a popped statement to the domain
b> vars = Only pass the lhs variable of a popped statement to the domain

1> decompose octagons into half spaces for negation during clause learning. Show
example of octagons when complementing half spaces.
2> for relational8 (proved successfully), but no decision is made. assume(x==y || x==-y)
3> domain refinement in ACDL

Observation:
------------
With forward iteration strategy and per statement based live variable where only
lhs variable is passed to the domain using octagons caused relational4 to make
12 decisions -- but still did not terminate. 

Status of Running relational examples with octagon domain:
----------------------------------------------------------
Running relational1  [OK]
Running relational2^CKilled by signal 2  [FAILED]
Running relational3  [OK]
Running relational4sh: line 1: 34261 Aborted                 (core
    dumped) ../../../src/summarizer/2ls --verbosity 10 --acdl --acdl-decision
ordered --acdl-conflict first-uip --acdl-propagate forward --inline
--octagons main.c > main.out 2>&1 [FAILED]
Running relational5  [FAILED]
Running relational6  [OK]
Running relational7  [OK]

Meeting on 4th october, 2016
-----------------------------
0> pre-process SSA -- heavy-weight implementation, does not terminate for
relational2 even after 40 mins -- does not change the SSA for relational3.
1> pre-process -- change the following statement to a new form for which it
is hard to identify non-leaf variable 
(E) x#phi27 == ($guard#26 ? x#26 : x#24) changed to 
$guard#26 ? x#26 == x#phi27 : x#24 == x#phi27 
For the initial statement, it is easy to identify x#phi27 as left hand side
varaible needed for initializing worklist with leaf varaible, whereas it is 
not possible for the simplified statement to identify x#phi27 as lhs varaible.

2> relational4 functions explicitly inlined by changing code -- octagon domain
terminated -- too many deductions
3> octagon complement operation not implemented in Apron 
4> Future work -- domain refinement, incremental solving, handling loops using
invariant synthesis.
5> With pre-processing, relational3 and relatioanl4 became faster whereas
bottom9 became extremely slower. 

Important issue
----------------
The following program in Interproc took less than second and only 50 approx
deductions with octagon domain. ACDL took more than 7 hrs to finish with close
to 2000 octagonal deductions using chaotic iteration strategy.

var x : int, res1 : int, res2 : int, y : int, state : int;
begin
assume x>=1 and x<=10;
res1 = 2 * x;
y = x;
y = y + 1;
x = x - 1;
if x != 0 then 
while(x != 0) do
y = y + 1;
x = x - 1;
done;
endif;
res2 = y; 
end
The final list of deductions are as follow:
|res1-2>=0; -res1+20>=0; -res1+res2+9>=0; res1+res2-4>=0;
res2-2>=0; -res1-res2+40>=0; res1-res2+18>=0; -res2+20>=0;
-res1+x+20>=0; res1+x-2>=0; -res2+x+20>=0;
res2+x-2>=0;
x>=0; -res1-x+20>=0;
res1-x-2>=0; -res2-x+20>=0;
res2-x-2>=0;
-x>=0;
-res1+y+9>=0;
res1+y-4>=0;
-res2+y>=0;
res2+y-4>=0;
-x+y-2>=0;
x+y-2>=0;
y-2>=0;
-res1-y+40>=0;
res1-y+18>=0;
-res2-y+40>=0;
res2-y>=0;
-x-y+20>=0;
x-y+20>=0;
-y+20>=0|]
